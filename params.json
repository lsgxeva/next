{"name":"Next","body":"# next\r\n\r\nnext 是一个为callback风格的异步编程提供支持的工具库。\r\nnext和[Async.js](https://github.com/caolan/async)的不同之处在于：async是调用函数, next是生成函数\r\n\r\n\r\n\r\n## 优势\r\n* 函数复用--\r\n针对函数而不是针对过程，可以对函数进行组合和连接。采用node风格的callback机制，直接可以复用系统函数。\r\n\r\n* 扁平化callback层次--\r\n使用next.pipe(fn1, fn2, fnN)连接函数，扁平化callback层次。\r\n\r\n* 统一的异常处理--\r\n在pipe、map、parallel等方法中进行组合的函数，一旦发生异常，则会统一跳到运行时传入callback进行处理，不用重复判断每级的error。\r\n\r\n## API\r\n\r\n### pipe([fn1], [fn2], [fnN])\r\n生成一个函数，先调用fn1，完成之后以fn1的返回值调用fn2，以此类推。\r\n在调用的时候如果有异常，直接跳到运行时传入的callback\r\n\r\n```javascript\r\nvar add2 = next.pipe(\r\n  function(num, callback) { callback(null, num + 1, num + 2) },\r\n  function(num1, num2, callback) { callback(null, num1 + 3, num2 + 3) }\r\n);\r\n\r\nadd2(1, function() {\r\n  console.log(arguments);\r\n});\r\n\r\n// result: [null, 5, 6]\r\n```\r\n\r\n### map(fn)\r\n生成一个函数，遍历入参每一个元素，调用fn。收集完结果之后按照传入顺序返回。\r\n```javascript\r\nvar addEach = next.map(\r\n  function(num, callback) { callback(null, num + 1) }\r\n);\r\n\r\naddEach([1,2,3], function() {\r\n  console.log(arguments);\r\n});\r\n// result: [null, [2,3,4]]\r\n\r\n```\r\n\r\n### parallel(fn1, [fn2], [fnN])\r\n生成一个函数，以当前参数调用每个fn，收集结果之后返回\r\n```javascript\r\nvar parallelAction = next.parallel(\r\n  function(num, callback) { callback(null, num + 1) },\r\n  function(num, callback) { callback(null, num + 2) }\r\n);\r\n\r\nparallelAction(1, function() {\r\n  console.log(arguments);\r\n});\r\n// result: [null, 2,3]\r\n\r\n```\r\n\r\n### concurrency(fn, limit, [onDrain])\r\n生成一个函数，使得同时运行的fn不超过limit个，超过的调用将被缓存，当有fn执行完毕之后再执行。当所有的fn调用完毕时触发onDrain\r\n```javascript\r\nvar throttledRunner = next.concurrency(function(a, callback) {\r\n  console.log('start:' + a);\r\n  setTimeout(function() {\r\n    console.log('end:' + a);\r\n    callback(a);\r\n  }, Math.random() * 3000);\r\n}, 5, function() {\r\n  console.log('drain');\r\n});\r\n\r\nfor (var i = 0; i < 1000; i++) {\r\n  throttledRunner(i, function() {});\r\n}\r\n\r\n```\r\n\r\n### rescue(fn, rescuer)\r\nrescuer == (err, callback) -> \r\n生成一个函数，当发生异常时，由rescuer捕获，而不是跳转到运行时的callback。\r\nrescuer接受error和callback作为参数，可以选择返回到正常的分支，或者继续抛出异常。\r\n```javascript\r\nnext.rescue(function(a, callback) {\r\n  console.log('raise exception:' + a);\r\n  callback(a);\r\n}, function(err, callback) {\r\n  console.log('rescue exception');\r\n  callback(null, err + ' is rescued')\r\n})('error', function() {\r\n  console.log(arguments)\r\n})\r\n\r\n// result:\r\n//rescue\r\n//raise exception:error\r\n//rescue exception\r\n\r\n```\r\n\r\n\r\n### echo()\r\n辅助函数，直接返回参数\r\n```javascript\r\nnext.echo([1,2,3], function() {\r\n  console.log(arguments);\r\n});\r\n// result: [null, [1,2,3]]\r\n\r\n```\r\n\r\n在parallel的时候，使用echo可以返回原参数\r\n\r\n```javascript\r\nvar parallelAction = next.parallel(\r\n  next.echo,\r\n  function(num1, num2, callback) { callback(null, num1 + 1, num2 + 1) },\r\n  function(num1, num2, callback) { callback(null, num1 + 2, num2 + 2) }\r\n);\r\n\r\nparallelAction(1, 1, function() {\r\n  console.log(arguments);\r\n});\r\n// result: [null, 1, 1, 2, 3, 3]\r\n\r\n```\r\n\r\n\r\n## 一些功能示例\r\n### [compress](https://github.com/youngjay/next/blob/master/examples/compress/compress.js)\r\n从页面上读取script标签src -> 获取js文件内容 -> 调用uglify-js压缩 -> 写文件\r\n\r\n","tagline":"为callback风格的异步编程提供支持的工具库","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}